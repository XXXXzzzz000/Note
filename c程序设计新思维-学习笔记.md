# c程序设计新思维-学习笔记

## 译者序

本书的第 3.3 节“用 Autotools 打包代码”，我个人认为这个技术有些过时。目前流行的 build system 是 CMake 系统，它在移植性和易用性上都要比 Autotoolson工具要好。所以 CMake 是新开发系统的首选 build system，也是未来的潮流。

## 前言

- 除非特别地说明，本书的内容遵从 ISO C99 和 C11 标准。

### c语言标准的历史

1. K&R (1978) C 语言的第一个事实上的标准[Kernighan，1978]
2. ANSI C89 (1989) 1989年,ANSI 出版了他们的标准，并在 K&R 的基础上做出了一定的提高
3. ISO C99 (1999) 多数的编译器在支持 C99 的同时都增加或减少了一些特性
4. C11 (2011)

### POSIX 标准

- 这个标准最早由电气和电子工程师协会（ IEEE）在 1988 年建立，提供了一个类UNIX 操作系统的公共基础。它定义的规格中包括 shell 脚本如何工作，像 ls、grep 之类的命令行应该如何工作，以及 C 程序员希望能用到的一些 C 库等.
- 除了来自 Microsoft 的一系列操作系统产品，当前几乎所有你可以列举出的操作系统都是建立在 POSIX 兼容的基础上： Linux、 Mac OS X、 iOS、 WebOS、 Solaris、BSD——甚至 Windows Servers 也提供 POSIX 子系统。
- 两个 POSIX 的实现版本因为有较高的流行度和影响力，值得我们注意
  - BSD
  - GNU
- 从法律意义上说， BSD 授权比 GNU 授权稍微宽容。由于很多群体对这些授权的政治和商业意义深感担心，实际上你会经常发现多数工具同时提供 GNU和 BSD版本。例如， GNU 的编译器组合（ gcc）和 BSD 的 clang 都可以说是顶级的 C 编译器。

### 示例代码

<https://github.com/b-k/21st-Century-Examples>
引用出处:
  “ C 程序设计新思维（第 2 版） Ben Klemens(O’Reilly)。 版权 2014 Ben Klemens, 978-1-491-90389-6”

## 第一章 准备方便的编译环境

### 1.1使用包管理工具

以下这些包是必须安装的。
- 编译器，必须安装 gcc；也可以选择安装 Clang。
- GDB 调试器。
- Valgrind，用于测试 C 内存使用错误。
- Gprof，用于运行效率评测。
- Make，使得你不用直接调用编译器。
- Pkg-config，用于查找库。
- Doxygen，用于生成程序文档。
- Text editor, 目前有几百个文本编辑器可以选择，这里给出几个主观的推荐。
  - Emacs 和 Vim 是计算机老手的最爱。 Emacs 几乎涵盖了很多的功能（ E代表 extensible，可扩展的）； Vim 更小型化，并且有很多友好的功能键。如果你是一个编辑器的重度用户， 那么你需要从这两个编辑器中选择一个来进一步学习。
  - Kate非常友好，也有吸引人的界面，能提供我们开发程序时需要的一些功能，例如语法高亮。
  - 最后的一个选项是 Nano，使用上最简单，是基于文本模式的编辑器。即使你没有 GUI 界面，也可以使用它。
- 如果你是 IDE 的爱好者，那就安装一个（或者几个）。同样有很多的选择。这里只是给出一些推荐。
  - Anjuta：属于 GNOME 家族，可以方便地使用 GNOME GUI builder工具Glade。
  - KDevelop：属于 KDE 家族。
  - XCode：苹果公司 OS X的 IDE。
  - Code::blocks：相对简单，在 Windows 下工作。
  - Eclipse：拥有很多按钮和杯架的“豪华跑车”，跨平台。在本章的后面，我还会介绍一些强力工具。
- Autotools： Autoconf、 Automake、 libtool。
- Git。
- 其他的 shell，例如 Z shell。

当然，还有一些 C 库能够避免你重新发明“轮子”（更准确的类比是，重新发明“火
车头”）。你可以获得更多的库，下面这些库是我们要在本书中用到的。
- libcURL。
- libGLib。
- libGSL。
- libSQLite3。
- libXML2。

**注意:**C 语言库没有一致的命名标准，你必须要了解你的包管理器是如何将一个单独的包分解成不同的子部分的。一般有一个供用户使用的包，同时还有一个供开发者使用的包，所以请在选择基本的包的同时，选择带有-dev 或者-devel 的包。某些系统将文档分拆在独立的包中。也有的要求你单独下载带有调试符号表的包。如果你在没有调试符号表的包上运行 GDB，那么 GDB 会要求你下载带有调试符号表的包.

### 1.3 链接函数库的方式

#### 1.3.1 一些我喜欢的选项

- -g,表示加入调试符号。
- -std=gnu11,这是 gcc 特有的选项,允许你使用符合 C11 和 POSIX 标准的代码
- -O3 显示出这里的优化等级是三级,
- -Wall 添加编译器警告
- 你可能想加上-Werror 编译选项,这样你的编译器将把警告当作错误来处理

#### 1.3.2 路径

##### 在一个典型的安装中,库可能存放的地方至少有三个。
  - 操作系统的厂家可能预定义了一两个自己用来安装库文件的目录。
  - 可能存在为本地系统管理员准备的用于安装包的目录,并且不会被来自厂家的下一次操作系统更新所覆盖。系统管理员也可能用一个特殊的破解版本的库覆盖系统缺省的版本。
  - 用户一般来说没有向这些路径写操作的权限,但是有从他们的主目录利用那些库的权限。
 
**注意:**你可以在任何 POSIX 标准系统中试一下 find /-type f | wc –l,用来得到一个粗略的文件数。
##### 在编译时指定头文件或库的位置
- -I 添加指定的路径到头文件的搜索路径范围内,
- -L 添加指定的路径到库的搜索路径范围内。

  **注意顺序问题**。如果你有一个叫作 specific.o 的文件依赖于 Libbroad 库,而Libbroad 库依赖于 Libgeneral,那么你应该输入:
    ```
    gcc specific.o -lbroad –lgeneral
    ```

##### 你可以这样理解链接器的工作方式:
链接器首先查看第一个目标——specific.o,将无法解析的函数、结构和变量名记入一个列表。然后链接器查看下一个目标——lbroad,并在这个目标内搜索列表中仍然缺失的项目,同时有可能在列表中添加新的项目;接着在-lgeneral查找仍然缺失的项目。如果直到搜索完最后的目标仍然存在未解析的符号(包括在最后的隐含的-lc) ,链接器将终止运行并向用户给出最后剩下的未解析项目。

你无疑可以用硬盘搜索的方式来查找,如在你的机器或 POSIX 环境中使用:来搜索/usr 中以 libuseful 开头的文件。
```
find /usr -name 'libuseful*'
```
当你发现 Libuseful 库的共享目标文件在
/some/path/lib 中,那么几乎可以肯定对应的头文件一定在/some/path/include 中

pkg-config
,在
我个人计算机的命令行上输入以下两行命令:
```
pkg-config --libs gsl libxml-2.0
pkg-config --cflags gsl libxml-2.0
得到下面两行输出:
-lgsl -lgslcblas -lm -lxml2
-I/usr/include/libxml2
这些正是我用来编译 GSL 和 LibXML2 所需要的所有选项。
```



